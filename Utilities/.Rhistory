icespal <- c('#939DBD','#012B5B','#7FA99C')
names(icespal)<- c('lb','db','lg')
source(paste(pathdir,"Utilities/Libraries_VMEadvice.R",sep="/"))
# load the workspace with all layers
load(paste(pathdir,"2-Data processing/Map_layer_workspace.RData",sep="/"))
# Load source data for map layer key tables
map1layers <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/MapLayerDesc.xlsx',1)
map2layers <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/MapLayerDesc.xlsx',2)
scenop     <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/ScenarioOptions.xlsx',1)
# Load source data used for tables 1 and 2
load(paste(pathdir,"2-Data processing/Table1_underlyingdata.RData",sep="/"))
# define fishable domain in table 2 - for now either EU or NEAFC
FishD <- "EU"
# set data call year
datacallyear <- 2021
newyear_fished <- (datacallyear-1):(datacallyear-3)
Region_ID <- "Celtic Seas"
# set the ecoregion of interest
subreg <- subset(ICESEcReg,ICESEcReg$Ecoregion ==Region_ID)
scen11 <- st_intersection(st_make_valid(scen11),subreg)
scen12 <- st_intersection(scen12,subreg)
scen21 <- st_intersection(scen21,subreg)
scen22 <- st_intersection(scen22,subreg)
shapeEEZ <- st_intersection(shapeEEZ,subreg)
EUFootp <- st_intersection(EUFootp,subreg)
#EUFootp_mob <- st_intersection(EUFootp_mob,subreg)
# EUFootp_stat <- st_intersection(EUFootp_stat,subreg)
#Footprint_both <- st_intersection(Footprint_both,subreg)
#Footprint_mobile <- st_intersection(Footprint_mobile,subreg)
#Footprint_static <- st_intersection(Footprint_static,subreg)
NEAFCFootp <- st_intersection(NEAFCFootp,subreg)
NEAFCReg <- st_intersection(NEAFCReg,subreg)
#clos_EU <- st_make_valid(clos_EU)
#clos_EU <- st_intersection(clos_EU,subreg)
clos_neafc <- st_intersection(clos_neafc,subreg)
VMEgrid_new <- st_intersection(VMEgrid_new,subreg)
VMEgrid_old <- st_intersection(VMEgrid_old,subreg)
Elements <- st_intersection(Elements,subreg)
Reg_depth <- st_intersection(Reg_depth,subreg)
head(table1)
head(VMEgrid_new)
table(VMEgrid_new$VME_Class ==3)
count(VMEgrid_new$VME_Class ==3)
length((VMEgrid_new$VME_Class ==3)==TRUE)
(VMEgrid_new$VME_Class ==3)
count(VMEgrid_new$VME_Class ==3)
table(VMEgrid_new$VME_Class ==3)["TRUE"]
The ICES VME database contains
```{r }
table(VMEgrid_new$VME_Class ==3)["TRUE"]
```
load("C:/Users/danie/Documents/Online for git/FBIT/1 - Input env/Baltic Sea_MSFD_per_csquare.RData")
head(msfd_csq)
table(VMEgrid_new$VME_Class ==3)["TRUE"]
table(VMEgrid_new$VME_Class ==3)["TRUE"][1]
as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"])
as.numeric(table(VMEgrid_new$VME_Class %in% c(0,1,2))["TRUE"])
datacallyear
as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"])
paste(as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"]))
paste("The ICES VME database contains", as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"]),"VME habitat and",as.numeric(table(VMEgrid_new$VME_Class %in% c(0,1,2))["TRUE"]),"VME indicator c-squares(as of",datacallyear,".)",sep=" ")
paste("The ICES VME database contains ", as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"])," VME habitat and ",as.numeric(table(VMEgrid_new$VME_Class %in% c(0,1,2))["TRUE"])," VME indicator c-squares(as of ",datacallyear,").",sep="")
For the purpose of this assessment, evidence of VME occurrence is aggregated at the scale of individual C-square cells where VME habitats or indicator taxa are assumed to be homogeneously distributed. Similarly, fishing effort information is aggregated at the scale of C-square cells.
```{r }
paste("The ICES VME database contains ", as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"])," VME habitat and ",as.numeric(table(VMEgrid_new$VME_Class %in% c(0,1,2))["TRUE"])," VME indicator c-squares (as of June ",datacallyear,").",sep="")
```
This information has been collected through various gear types and survey methods. The fishery closure scenarios for VME protection are based on the method described in the ACOM technical guidelines based on WKVMEBM (ICES 2022).
Bottom fishing (static and mobile) is the single most important human-induced pressure on the seafloor in this area, see further ICES ecosystem overviews: https://www.ices.dk/advice/ESD/Pages/Ecosystem-overviews.aspx.
load("C:/Users/danie/Documents/Online for git/VME-Advice/1-Input data/Region_depth_prelim.Rdata")
head(depth)
cat(as.numeric(table(VMEgrid_new$VME_Class ==3)["TRUE"]))
head(depth)
head(VMEgrid_new)
tail(VMEgrid_new)
VME <- read.csv(paste(pathdir_nogit,
"VME data repository/VME observations and csquares/VME_observations_datacall_2021.csv"),
sep="/"),header=T,sep=",",row.names = NULL)
paste(pathdir_nogit,
"VME data repository/VME observations and csquares/VME_observations_datacall_2021.csv"),
sep="/")
VME <- read.csv(paste(pathdir_nogit,
"VME data repository/VME observations and csquares/VME_observations_datacall_2021.csv",
sep="/"),header=T,sep=",",row.names = NULL)
head(VME)
reg  <- subset(table1,table1$Ecoregion == Region_ID)
c(length(which(reg$New_VMEs==3 & reg$cat =="de2_4")),length(which(reg$New_VMEs==3 & reg$cat =="de4_8")),
length(which(reg$New_VMEs==3 & reg$cat =="de8")))
cat(sum(c(length(which(reg$New_VMEs==3 & reg$cat =="de2_4")),length(which(reg$New_VMEs==3 & reg$cat =="de4_8")),
length(which(reg$New_VMEs==3 & reg$cat =="de8")))))
cat(sum(c(length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat =="de2_4")),length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat  =="de4_8")), length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat =="de8")))))
reg  <- subset(table1,table1$Ecoregion == Region_ID)
subset(VMEgrid_new,VMEgrid_new$VME_Class ==3 subset(VMEgrid_old,VMEgrid_old$VME_Class ==3)
reg  <- subset(table1,table1$Ecoregion == Region_ID)
cat(sum(c(length(which(reg$New_VMEs==3 & reg$cat =="de2_4")),length(which(reg$New_VMEs==3 & reg$cat  =="de4_8")), length(which(reg$New_VMEs==3 & reg$cat =="de8")))))
cat(sum(c(length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat =="de2_4")),length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat  =="de4_8")), length(which(reg$New_VMEs %in% c(0,1,2) & reg$cat =="de8")))))
cat(sum(c(length(which(reg$New_VMEs %in% c(2) & reg$cat =="de2_4")),length(which(reg$New_VMEs %in% c(2) & reg$cat  =="de4_8")), length(which(reg$New_VMEs %in% c(2) & reg$cat =="de8")))))
cat(sum(c(length(which(reg$New_VMEs %in% c(1) & reg$cat =="de2_4")),length(which(reg$New_VMEs %in% c(1) & reg$cat  =="de4_8")), length(which(reg$New_VMEs %in% c(1) & reg$cat =="de8")))))
cat(sum(c(length(which(reg$New_VMEs %in% c(0) & reg$cat =="de2_4")),length(which(reg$New_VMEs %in% c(0) & reg$cat  =="de4_8")), length(which(reg$New_VMEs %in% c(0) & reg$cat =="de8")))))
textreg   <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/Text_ICESregions.xlsx',"Celtic Seas")
textreg   <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/Text_ICESregions.xlsx',Region_ID)
Region_ID <- "Celtic Seas"
textreg   <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/Text_ICESregions.xlsx',Region_ID)
textreg
cat(textreg[1,3])
textreg   <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/Text_ICESregions.xlsx',Region_ID)
cat(textreg[1,3])
tt <- subset(textreg,textreg$Tab == "Overview")
cat(tt[,3])
cat(tt[1,3])
cat(tt[2,3])
for(i in 1:nrow(tt)){
cat(tt[i,3])
print("\n")
}
for(i in 1:nrow(tt)){
cat(tt[i,3])
print(\n)
}
cat(tt[i,3],"\n")
cat(paste(tt[i,3],"\n",sep="")
print(\n)
}
```
cat(paste(tt[i,3],"\n",sep=""))
paste(tt[i,3],"\n",sep="")
cat("\n")
for(i in 1:nrow(tt)){
cat("\n")
cat(tt[i,3])
}
for(i in 1:nrow(tt)){
cat("\n")
(tt[i,3])
}
for(i in 1:nrow(tt)){
cat("\n")
print(tt[i,3])
}
for(i in 1:nrow(tt)){
cat("\n")
cat(print(tt[i,3]))
}
for(i in 1:nrow(tt)){
print("\n")
cat(print(tt[i,3]))
}
for(i in 1:nrow(tt)){
cat("\n")
cat(tt[i,3])
}
cat("\n")
for(i in 1:nrow(tt)){
c(cat("\n"),cat(tt[i,3]))
}
for(i in 1:nrow(tt)){
cat(cat("\n"),cat(tt[i,3]))
}
for(i in 1:nrow(tt)){
cat(("\n"),cat(tt[i,3]))
}
for(i in 1:nrow(tt)){
cat("\n",cat(tt[i,3]))
}
for(i in 1:nrow(tt)){
cat("\n",tt[i,3])
}
for(i in 1:nrow(tt)){
cat(paste("\n",tt[i,3]))
}
for(i in 1:nrow(tt)){
cat('<br>')
cat(tt[i,3])
}
cat('\n')
cat('\n')
cat(tt[i,3])
pathdir <- "C:/Users/danie/Documents/Online for git/VME-Advice"
pathdir_nogit <- "C:/Users/danie/Documents/Online for git/VME-advice_noGIT" # stores the VMS and VME data from sharepoint
source(paste(pathdir,"Utilities/Libraries_VMEadvice.R",sep="/"))
# load the workspace with all layers
load(paste(pathdir,"2-Data processing/Map_layer_workspace.RData",sep="/"))
pathdir <- "C:/Users/danie/Documents/Online for git/VME-Advice"
pathdir_nogit <- "C:/Users/danie/Documents/Online for git/VME-advice_noGIT" # stores the VMS and VME data from sharepoint
source(paste(pathdir,"Utilities/Libraries_VMEadvice.R",sep="/"))
# load the workspace with all layers
load(paste(pathdir,"2-Data processing/Map_layer_workspace.RData",sep="/"))
# Load source data for map layer key tables
map1layers <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/MapLayerDesc.xlsx',1)
map2layers <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/MapLayerDesc.xlsx',2)
scenop     <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/ScenarioOptions.xlsx',1)
# Load source data used for tables 1 and 2
load(paste(pathdir,"2-Data processing/Table1_underlyingdata.RData",sep="/"))
# define fishable domain in table 2 - for now either EU or NEAFC
FishD <- "EU"
# set data call year
datacallyear <- 2021
newyear_fished <- (datacallyear-1):(datacallyear-3)
Region_ID <- "Celtic Seas"
# set the ecoregion of interest
subreg <- subset(ICESEcReg,ICESEcReg$Ecoregion ==Region_ID)
scen11 <- st_intersection(st_make_valid(scen11),subreg)
scen12 <- st_intersection(scen12,subreg)
scen21 <- st_intersection(scen21,subreg)
scen22 <- st_intersection(scen22,subreg)
shapeEEZ <- st_intersection(shapeEEZ,subreg)
EUFootp <- st_intersection(EUFootp,subreg)
Ref_comb <- st_intersection(Ref_comb,subreg)
Ref_mobile <- st_intersection(Ref_mobile,subreg)
Ref_static <- st_intersection(Ref_static,subreg)
New_comb <- st_intersection(New_comb,subreg)
New_mobile <- st_intersection(New_mobile,subreg)
New_static <- st_intersection(New_static,subreg)
NEAFCFootp <- st_intersection(NEAFCFootp,subreg)
NEAFCReg <- st_intersection(NEAFCReg,subreg)
clos_neafc <- st_intersection(clos_neafc,subreg)
VMEgrid_new <- st_intersection(VMEgrid_new,subreg)
VMEgrid_old <- st_intersection(VMEgrid_old,subreg)
Elements <- st_intersection(Elements,subreg)
Reg_depth <- st_intersection(Reg_depth,subreg)
textreg   <- openxlsx::read.xlsx('C:/Users/danie/Documents/Online for git/VME-Advice/Output/Text_ICESregions.xlsx',Region_ID)
# select all new c-squares
# does this work when c-squares are being removed? / if updated it works!
VMEgrid_old$uni  <- paste(VMEgrid_old$csquares,VMEgrid_old$VME_Class)
VMEgrid_new$uni  <- paste(VMEgrid_new$csquares,VMEgrid_new$VME_Class)
VMEgrid_new      <- VMEgrid_new[!(VMEgrid_new$uni %in% VMEgrid_old$uni ),]
# names for the leaflet
nam <- c("Ecoregion boundaries","EEZ boundaries","Depth zone 400-800m",
"Existing VME C-sq.","New VME C-sq.","EU fishable domain (prelim.)",
"Fished area (S+M)","Reference fished area (S)","Fished area (S)",
"Reference fished area (M)","Fished area (M)",
"Existing VME physical elements","Updated VME physical elements (prelim.)",
"NEAFC Convention Area","Existing NEAFC Closures","NEAFC fishable domain")
# Create colour palette for VMEs
VMEcolours <- c("#2E8AC6","#F40000","#F67E11","#FDF100")
VMEpal <- colorFactor(VMEcolours, VMEgrid_old$VME_Class_Lab)
# set region
mxt <- st_bbox(subreg)
#
mfs <- leaflet() %>%
fitBounds(mxt[[1]],mxt[[2]],mxt[[3]],mxt[[4]]) %>%
addProviderTiles(providers$Esri.WorldImagery) %>%
# boundaries
addPolygons(data = ICESEcReg, group = nam[1],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = shapeEEZ, group = nam[2],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = Reg_depth, group = nam[3],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "yellow") %>%
# VME c-sqs
addPolygons(data = VMEgrid_old, group = nam[4],
stroke = FALSE, fillOpacity = 1, smoothFactor = 0.5,
color = ~VMEpal(VME_Class_Lab)) %>%
addPolygons(data = VMEgrid_new, group = nam[5],
stroke = FALSE, fillOpacity = 1, smoothFactor = 0.5,
color = ~VMEpal(VME_Class_Lab)) %>%
# EU footprint and fishing areas
addPolygons(data = EUFootp, group = nam[6],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addPolygons(data = New_comb, group = nam[7],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "red") %>%
addPolygons(data = Ref_static, group = nam[8],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addPolygons(data = New_static, group = nam[9],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "red") %>%
addPolygons(data = Ref_mobile, group = nam[10],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addPolygons(data = New_mobile, group = nam[11],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "red") %>%
# elements
addPolygons(data = Elements, group = nam[12],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addPolygons(data = Elements, group = nam[13],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "red") %>%
# NEAFC information
addPolygons(data = NEAFCReg, group = nam[14],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "red") %>%
addPolygons(data = clos_neafc, group = nam[15],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = NEAFCFootp, group = nam[16],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addLegend(group = "VME Class",
position = "bottomright",
colors = VMEcolours, labels= levels(VMEgrid_old$VME_Class_Lab)) %>%
# Layers control
addLayersControl(
overlayGroups = nam[1:16],
options = layersControlOptions(collapsed = FALSE))%>%
# hide
hideGroup(nam[5:16])
mfs
nam <- c("Ecoregion boundaries","EEZ boundaries",
"Depth zone 400-800m (prelim.)", "Existing NEAFC closures",
"Existing VME polygon S1 O1","New VME polygon S1 O1",
"Existing VME polygon S1 O2","New VME polygon S1 O2",
"Existing VME polygon S2 O1","New VME polygon S2 O1",
"Existing VME polygon S2 O2","New VME polygon S2 O2",
"Existing VME polygon S2 O3","New VME polygon S2 O3",
"NEAFC fishable domain","NEAFC Convention Area",
"EU fishable domain (prelim.)")
# add information for scenario 1 option 1 closures
scen <- scen11
# get all c-sq with closures old + new
VMEgrid <- subset(VMEgrid_old,!(VMEgrid_old$csquares %in% VMEgrid_new$csquares))
VMEgrid <- rbind(VMEgrid,VMEgrid_new)
# Assign VME grid cells to closure
intVME <- st_join(VMEgrid,scen)
# Add area (m2)
intVME$aream2 <- st_area(intVME)
# Create table with sum of the area in each VME category by closure
VMEareas <- intVME %>%
st_drop_geometry() %>%
filter(!is.na(id)) %>%
pivot_wider(id_cols = id,
names_from = VME_Class,
values_from = aream2,
values_fn = sum) %>%
mutate(across(2:5,~as.integer(.)))  %>%
mutate(across(everything(),~replace_na(.x, 0)))
# Add the area to closure polygons attribute table
scen <- merge(scen,VMEareas,by='id')
# Calculate area of closure
scen$closureA <- st_area(scen)
# Calculate percent area of closure in each VME class
scen$pctHab <- round(100*(scen$`3`/scen$closureA))
scen$pctHigh <- round(100*(scen$`2`/scen$closureA))
scen$pctMed <- round(100*(scen$`1`/scen$closureA))
scen$pctLow <- round(100*(scen$`0`/scen$closureA))
#
mfs2 <- leaflet() %>%
fitBounds(mxt[[1]],mxt[[2]],mxt[[3]],mxt[[4]]) %>%
addProviderTiles(providers$Esri.WorldImagery) %>%
addMapPane("scens", zIndex = 420) %>%
# boundaries
addPolygons(data = ICESEcReg, group = nam[1],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = shapeEEZ, group = nam[2],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = Reg_depth, group = nam[3],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "yellow") %>%
# existing closures
addPolygons(data = clos_neafc, group = nam[4],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "white") %>%
addPolygons(data = scen11_prev, group=nam[5],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 2, color = "orange") %>%
# potential closures
addPolygons(data = scen,
group = nam[6],
layerId = scen$id,
stroke = FALSE,
fillOpacity = 0.5,
#smoothFactor = 0.5,
fillColor =  "white",
color = "transparent",
highlightOptions = highlightOptions(stroke='white',
color = "white",
fillOpacity = 1,
weight = 2,),
popup = paste0("<b>Closure area: </b>", round(scen$closureA/1000000,1), " Km<sup>2</sup>",
"<br><br><b>Proportion of VME:</b>",
"<table>
<tr>
<th>Category</th>
<th>% of Area</th>
</tr>
<tr>
<td>VME Habitat</td>
<td align='right'>", scen$pctHab, "</td>
</tr>
<tr>
<td>VME Index - High</td>
<td align='right'>",scen$pctHigh,"</td>
</tr>
<tr>
<td>VME Index - Mod</td>
<td align='right'>",scen$pctMed,"</td>
</tr>
<tr>
<td>VME Index - Mod</td>
<td align='right'>",scen$pctLow,"</td>
</tr>
</table>"),
options = pathOptions(pane = "scens")) %>%
addPolygons(data = scen12_prev, group=nam[7],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 2, color = "red") %>%
addPolygons(data = scen12, group=nam[8],fillColor =  "white", color = "transparent",stroke = FALSE, fillOpacity = 0.5) %>%
addPolygons(data = scen21_prev, group=nam[9],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 2, color = "#bcbddc") %>%
addPolygons(data = scen21, group=nam[10],fillColor =  "white", color = "transparent",stroke = FALSE, fillOpacity = 0.5) %>%
addPolygons(data = scen22_prev, group=nam[11],
stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 2, color = "#c7e9c0") %>%
addPolygons(data = scen22, group=nam[12],fillColor =  "white", color = "transparent",stroke = FALSE, fillOpacity = 0.5) %>%
#addPolygons(data = NULL, group=nam[13],
#            stroke = TRUE, fillOpacity = 0.1, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "#c7e9c0") %>%
addPolygons(data = scen23, group=nam[14],fillColor =  "white", color = "transparent",stroke = FALSE, fillOpacity = 0.5) %>%
# existing footprints
addPolygons(data = NEAFCFootp, group = nam[15],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
addPolygons(data = NEAFCReg, group = nam[16],
stroke = TRUE, fillOpacity = 0, smoothFactor = 0.5, opacity = 0.5, weight = 1, color = "red") %>%
addPolygons(data = EUFootp, group = nam[17],
stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, fillColor =  "white") %>%
# Layers control
addLayersControl(
overlayGroups = nam[c(1:12,14:17)],
options = layersControlOptions(collapsed = FALSE)) %>%
# hide
hideGroup(nam[c(6:12,14:17)])
mfs2
map2layers[,-2] %>%
kbl('html',escape = FALSE, align='l',col.names = c('Layer','Description')) %>%
kable_classic(full_width = F, position = "center",fixed_thead = T,font_size = 10,html_font = "Times") %>%
row_spec(0, bold = T)  %>%
row_spec(0:nrow(map2layers), extra_css = 'padding: 10px;vertical-align:top;') %>%
column_spec(1, width = "4.5cm") %>%
column_spec(2, width = "12cm")
scenop %>%
kbl('html',escape = FALSE, align='l',col.names = c('Scenario','Option',
'Description of C-square closures',
'Management implication')) %>%
kable_classic(full_width = F, position = "center",fixed_thead = T,font_size = 10,html_font = "Times") %>%
row_spec(0, bold = T)  %>%
row_spec(0:nrow(scenop), extra_css = 'padding: 10px;vertical-align:top;') %>%
column_spec(1, width = "3cm") %>%
column_spec(2, width = "3cm") %>%
column_spec(3, width = "12cm") %>%
column_spec(4, width = "12cm")
source(paste(pathdir,"Utilities/Compile_table2.R",sep="/")) # warnings okay
tab2[is.na(tab2)] <- ""
tab2[5,2:6] <- NA
tab2[8,2:6] <- NA
tab2[10,2:6] <- NA
tab2  %>%
kable('html',escape = FALSE, align='l',row.names = FALSE) %>%
kable_classic(full_width = F, position = "center",fixed_thead = T,font_size = 10,html_font = "Times") %>%
row_spec(0, bold = T, extra_css = 'padding: 3.5px;vertical-align:top;')  %>%
row_spec(1, extra_css = 'padding: 5px;vertical-align:top;border-bottom: 1px solid black;') %>%
row_spec(c(3,9),bold = T, background = icespal[['lg']], extra_css = 'padding: 5px;vertical-align:top;') %>%
row_spec(c(4:8,10:nrow(tab2)), extra_css = 'padding: 5px;vertical-align:top;') %>%
column_spec(1, width = "10cm",extra_css = 'padding-right: 10px;vertical-align:top;') %>%
column_spec(2:ncol(tab2), width = "4.5cm")
tab2
source(paste(pathdir,"Utilities/Compile_table2.R",sep="/")) # warnings okay
tab2
pathdir
source(paste(pathdir,"Utilities/Compile_table2.R",sep="/")) # warnings okay
# get region shapefile and table 1
Region <- subset(ICESEcReg,ICESEcReg$Ecoregion == Region_ID)
Regiontab1 <- subset(table1, table1$Ecoregion == Region_ID)
# get VME polygons in the region
scen11_R <- st_make_valid(st_intersection(scen11,Region))
scen12_R <- st_make_valid(st_intersection(scen12,Region))
scen21_R <- st_make_valid(st_intersection(scen21,Region))
scen22_R <- st_make_valid(st_intersection(scen22,Region))
scen23_R <- st_make_valid(st_intersection(scen23,Region))
# get fishable domain in the region
Fishdom <- st_intersection(eval(parse(text = paste(FishD,"Footp",sep=""))),Region)
Fishdom <- st_make_valid(Fishdom)
# get fished area in the region
Mobile_fish <- st_intersection(New_mobile,Region) ; Mobile_fish <- st_make_valid(Mobile_fish)
Static_fish <- st_intersection(New_static,Region) ; Static_fish <- st_make_valid(Static_fish)
Mobile_fish <- New_mobile ; Mobile_fish <- st_make_valid(Mobile_fish)
Static_fish <- New_static ; Static_fish <- st_make_valid(Static_fish)
# get fishing SAR in the region
vmsreg          <- readRDS(paste(pathdir_nogit,paste("VMS data repository/All_VMS_datacall",datacallyear,".rds",sep=""),sep="/"))
nam_fished      <- c(paste("SAR_total",newyear_fished,sep="_"))
indexcol_fished <- which(names(vmsreg) %in% nam_fished)
vmsreg$mobeff   <- rowMeans(vmsreg[indexcol_fished],na.rm=T)
vmsreg$mobeff[is.na(vmsreg$mobeff)] <- 0
Regiontab1 <- cbind(Regiontab1, vmsreg[match(Regiontab1$csquares,vmsreg$c_square), c("mobeff")])
colnames(Regiontab1)[ncol(Regiontab1)] <- "mobeff"
# make the table
tab2 <- as.data.frame(matrix(data=NA,nrow = 13, ncol= 6))
# calculate overlap with fishable domain
FD_scen11 <- st_intersection(scen11_R,Fishdom); FD_scen11 <- st_make_valid(FD_scen11)
tab2[4,2] <- round(sum(st_area(FD_scen11))/sum(st_area(Fishdom)) * 100,digits = 1)
FD_scen12 <- st_intersection(scen12_R,Fishdom); FD_scen12 <- st_make_valid(FD_scen12)
tab2[4,3] <- round(sum(st_area(FD_scen12))/sum(st_area(Fishdom)) * 100,digits = 1)
FD_scen21 <- st_intersection(scen21_R,Fishdom); FD_scen21 <- st_make_valid(FD_scen21)
tab2[4,4] <- round(sum(st_area(FD_scen21))/sum(st_area(Fishdom)) * 100,digits = 1)
FD_scen22 <- st_intersection(scen22_R,Fishdom); FD_scen22 <- st_make_valid(FD_scen22)
tab2[4,5] <- round(sum(st_area(FD_scen22))/sum(st_area(Fishdom)) * 100,digits = 1)
FD_scen23 <- st_intersection(scen23_R,Fishdom); FD_scen23 <- st_make_valid(FD_scen23)
tab2[4,6] <- round(sum(st_area(FD_scen23))/sum(st_area(Fishdom)) * 100,digits = 1)
# calculate for NEAFC only the overlap with closures (no information available for EU)
if (FishD == "NEAFC"){
cl_scen11 <- st_intersection(scen11_R,clos_neafc); cl_scen11 <- st_make_valid(cl_scen11)
tab2[5,2] <- round(sum(st_area(cl_scen11))/sum(st_area(scen11_R)) * 100,digits = 1)
cl_scen12 <- st_intersection(scen12_R,clos_neafc); cl_scen12 <- st_make_valid(cl_scen12)
tab2[5,3] <- round(sum(st_area(cl_scen12))/sum(st_area(scen12_R)) * 100,digits = 1)
cl_scen21 <- st_intersection(scen21_R,clos_neafc); cl_scen21 <- st_make_valid(cl_scen21)
tab2[5,4] <- round(sum(st_area(cl_scen21))/sum(st_area(scen21_R)) * 100,digits = 1)
cl_scen22 <- st_intersection(scen22_R,clos_neafc); cl_scen22 <- st_make_valid(cl_scen22)
tab2[5,5] <- round(sum(st_area(cl_scen22))/sum(st_area(scen22_R)) * 100,digits = 1)
cl_scen23 <- st_intersection(scen23_R,clos_neafc); cl_scen23 <- st_make_valid(cl_scen23)
tab2[5,6] <- round(sum(st_area(cl_scen23))/sum(st_area(scen23_R)) * 100,digits = 1)
}
# Number of VME polygons and their average areal extent (size)
tab2[6,2] <- paste(nrow(scen11_R)," (",round(mean(st_area(scen11_R)/10^6),digits=1)," km<sup>2</sup>)",sep="")
source(paste(pathdir,"Utilities/Compile_table2.R",sep="/")) # warnings okay
tab2[is.na(tab2)] <- ""
tab2[5,2:6] <- NA
tab2[8,2:6] <- NA
tab2[10,2:6] <- NA
tab2  %>%
kable('html',escape = FALSE, align='l',row.names = FALSE) %>%
kable_classic(full_width = F, position = "center",fixed_thead = T,font_size = 10,html_font = "Times") %>%
row_spec(0, bold = T, extra_css = 'padding: 3.5px;vertical-align:top;')  %>%
row_spec(1, extra_css = 'padding: 5px;vertical-align:top;border-bottom: 1px solid black;') %>%
row_spec(c(3,9),bold = T, background = icespal[['lg']], extra_css = 'padding: 5px;vertical-align:top;') %>%
row_spec(c(4:8,10:nrow(tab2)), extra_css = 'padding: 5px;vertical-align:top;') %>%
column_spec(1, width = "10cm",extra_css = 'padding-right: 10px;vertical-align:top;') %>%
column_spec(2:ncol(tab2), width = "4.5cm")
